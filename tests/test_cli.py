"""Tests for the roadmap CLI."""

import os
import tempfile
from unittest.mock import Mock, patch

import pytest
from click.testing import CliRunner

from roadmap.cli import main
from roadmap.models import Priority, Status


@pytest.fixture(autouse=True)
def reset_cli_state():
    """Reset CLI state between tests to prevent pollution."""
    # Clear any cached Click contexts and CLI state
    import os
    import sys
    
    # Store original environment
    original_cwd = os.getcwd()
    original_env = os.environ.copy()
    
    # Clear Click-related caches if they exist
    if hasattr(main, 'make_context'):
        try:
            ctx = main.make_context('main', [])
            ctx.reset()
        except:
            pass
    
    # Clear any module-level state
    if hasattr(sys.modules.get('roadmap.cli'), '_cached_core'):
        delattr(sys.modules['roadmap.cli'], '_cached_core')
    
    yield
    
    # Restore original state
    os.chdir(original_cwd)
    os.environ.clear()
    os.environ.update(original_env)


@pytest.fixture
def cli_runner():
    """Create an isolated CLI runner for testing."""
    from click.testing import CliRunner
    return CliRunner()


@pytest.fixture
def temp_dir():
    """Create a temporary directory for testing."""
    with tempfile.TemporaryDirectory() as tmpdir:
        old_cwd = os.getcwd()
        os.chdir(tmpdir)
        yield tmpdir
        os.chdir(old_cwd)


@pytest.fixture
def initialized_roadmap(temp_dir):
    """Create a temporary directory with initialized roadmap."""
    runner = CliRunner()
    result = runner.invoke(main, ["init"])
    assert result.exit_code == 0
    return temp_dir


def test_cli_version():
    """Test that the CLI shows version information."""
    runner = CliRunner()
    result = runner.invoke(main, ["--version"])
    assert result.exit_code == 0
    assert "0.1.0" in result.output


def test_cli_help(cli_runner):
    """Test that the CLI shows help information."""
    result = cli_runner.invoke(main, ["--help"])
    assert result.exit_code == 0
    assert "Roadmap CLI" in result.output


def test_init_command(temp_dir):
    """Test the init command."""
    runner = CliRunner()
    result = runner.invoke(main, ["init"])
    assert result.exit_code == 0
    assert "Initializing new roadmap" in result.output
    assert "Roadmap initialized successfully" in result.output


def test_init_command_already_initialized(initialized_roadmap):
    """Test init command when roadmap is already initialized."""
    runner = CliRunner()
    result = runner.invoke(main, ["init"])
    assert result.exit_code == 0
    assert "Roadmap already initialized" in result.output


def test_init_command_with_error(temp_dir):
    """Test init command with initialization error."""
    runner = CliRunner()
    with patch("roadmap.core.RoadmapCore.initialize") as mock_init:
        mock_init.side_effect = Exception("Test error")
        result = runner.invoke(main, ["init"])
        assert result.exit_code == 0
        assert "Failed to initialize roadmap" in result.output


def test_status_command_with_existing_roadmap(initialized_roadmap):
    """Test the status command when roadmap exists."""
    runner = CliRunner()
    result = runner.invoke(main, ["status"])
    assert result.exit_code == 0
    assert "Roadmap Status" in result.output


def test_status_command_without_roadmap(temp_dir):
    """Test status command when roadmap doesn't exist."""
    runner = CliRunner()
    result = runner.invoke(main, ["status"])
    assert result.exit_code == 0
    assert "Roadmap not initialized" in result.output


def test_issue_help(cli_runner):
    """Test issue command help."""
    result = cli_runner.invoke(main, ["issue", "--help"])
    assert result.exit_code == 0
    assert "Manage issues" in result.output


def test_issue_create_command(initialized_roadmap):
    """Test creating an issue."""
    runner = CliRunner()
    result = runner.invoke(main, ["issue", "create", "test-issue"])
    assert result.exit_code == 0
    assert "Created issue: test-issue" in result.output


def test_issue_create_with_options(initialized_roadmap):
    """Test creating an issue with all options."""
    runner = CliRunner()
    result = runner.invoke(
        main,
        [
            "issue",
            "create",
            "test-issue",
            "--priority",
            "high",
            "--milestone",
            "v1.0",
            "--labels",
            "bug",
            "--labels",
            "urgent",
        ],
    )
    assert result.exit_code == 0
    assert "Created issue: test-issue" in result.output
    assert "Priority: high" in result.output
    # Check for milestone parts due to ANSI color codes
    assert "Milestone:" in result.output and "v1.0" in result.output


def test_issue_create_without_roadmap(temp_dir):
    """Test creating issue without initialized roadmap."""
    runner = CliRunner()
    result = runner.invoke(main, ["issue", "create", "test-issue"])
    assert result.exit_code == 0
    assert "Roadmap not initialized" in result.output


def test_issue_create_with_error(initialized_roadmap):
    """Test issue creation with error."""
    runner = CliRunner()
    with patch("roadmap.core.RoadmapCore.create_issue") as mock_create:
        mock_create.side_effect = Exception("Test error")
        result = runner.invoke(main, ["issue", "create", "test-issue"])
        assert result.exit_code == 0
        assert "Failed to create issue" in result.output


def test_issue_list_command_empty(initialized_roadmap):
    """Test listing issues when none exist."""
    runner = CliRunner()
    result = runner.invoke(main, ["issue", "list"])
    assert result.exit_code == 0
    assert "No all issues found" in result.output


def test_issue_list_command_with_issues(initialized_roadmap):
    """Test listing issues when they exist."""
    runner = CliRunner()

    # Create some issues first
    runner.invoke(main, ["issue", "create", "issue-1", "--priority", "high"])
    runner.invoke(main, ["issue", "create", "issue-2", "--priority", "low"])

    result = runner.invoke(main, ["issue", "list"])
    assert result.exit_code == 0
    assert "issue-1" in result.output
    assert "issue-2" in result.output


def test_issue_list_with_filters(initialized_roadmap):
    """Test listing issues with filters."""
    runner = CliRunner()

    # Create issues with different attributes
    runner.invoke(main, ["issue", "create", "high-issue", "--priority", "high"])
    runner.invoke(main, ["issue", "create", "low-issue", "--priority", "low"])

    # Test priority filter
    result = runner.invoke(main, ["issue", "list", "--priority", "high"])
    assert result.exit_code == 0
    assert "high-issue" in result.output
    assert "low-issue" not in result.output


def test_issue_list_without_roadmap(temp_dir):
    """Test listing issues without initialized roadmap."""
    runner = CliRunner()
    result = runner.invoke(main, ["issue", "list"])
    assert result.exit_code == 0
    assert "Roadmap not initialized" in result.output


def test_issue_list_with_error(initialized_roadmap):
    """Test issue listing with error."""
    runner = CliRunner()
    with patch("roadmap.core.RoadmapCore.list_issues") as mock_list:
        mock_list.side_effect = Exception("Test error")
        result = runner.invoke(main, ["issue", "list"])
        assert result.exit_code == 0
        assert "Failed to list issues" in result.output


def test_issue_update_command(initialized_roadmap):
    """Test updating an issue."""
    runner = CliRunner()

    # Create issue first
    result = runner.invoke(main, ["issue", "create", "test-issue"])
    issue_id = None
    for line in result.output.split("\n"):
        if "ID:" in line:
            issue_id = line.split(":")[1].strip()
            break

    assert issue_id is not None

    # Update the issue
    result = runner.invoke(
        main,
        ["issue", "update", issue_id, "--status", "in-progress", "--priority", "high"],
    )
    assert result.exit_code == 0
    assert "Updated issue" in result.output


def test_issue_update_not_found(initialized_roadmap):
    """Test updating non-existent issue."""
    runner = CliRunner()
    result = runner.invoke(main, ["issue", "update", "nonexistent", "--status", "done"])
    assert result.exit_code == 0
    assert "Issue not found" in result.output


def test_issue_update_without_roadmap(temp_dir):
    """Test updating issue without initialized roadmap."""
    runner = CliRunner()
    result = runner.invoke(main, ["issue", "update", "test-id", "--status", "done"])
    assert result.exit_code == 0
    assert "Roadmap not initialized" in result.output


def test_issue_delete_command(initialized_roadmap):
    """Test deleting an issue."""
    runner = CliRunner()

    # Create issue first
    result = runner.invoke(main, ["issue", "create", "test-issue"])
    issue_id = None
    for line in result.output.split("\n"):
        if "ID:" in line:
            issue_id = line.split(":")[1].strip()
            break

    assert issue_id is not None

    # Delete the issue (using --yes to skip confirmation)
    result = runner.invoke(main, ["issue", "delete", "--yes", issue_id])
    assert result.exit_code == 0
    assert "Permanently deleted issue" in result.output


def test_issue_delete_not_found(initialized_roadmap):
    """Test deleting non-existent issue."""
    runner = CliRunner()
    result = runner.invoke(main, ["issue", "delete", "--yes", "nonexistent"])
    assert result.exit_code == 0
    assert "Issue not found" in result.output


def test_issue_delete_without_roadmap(temp_dir):
    """Test deleting issue without initialized roadmap."""
    runner = CliRunner()
    result = runner.invoke(main, ["issue", "delete", "--yes", "test-id"])
    assert result.exit_code == 0
    assert "Roadmap not initialized" in result.output


# Issue Commands Tests


def test_issue_create_command(initialized_roadmap):
    """Test creating an issue."""
    runner = CliRunner()
    result = runner.invoke(main, ["issue", "create", "test-issue"])
    assert result.exit_code == 0
    assert "Created issue: test-issue" in result.output


def test_issue_create_with_options(initialized_roadmap):
    """Test creating an issue with all options."""
    runner = CliRunner()
    result = runner.invoke(
        main,
        [
            "issue",
            "create",
            "test-issue",
            "--priority",
            "high",
            "--milestone",
            "v1.0",
            "--labels",
            "bug",
            "--labels",
            "urgent",
        ],
    )
    assert result.exit_code == 0
    assert "Created issue: test-issue" in result.output
    assert "Priority: high" in result.output
    # Check for milestone parts due to ANSI color codes
    assert "Milestone:" in result.output and "v1.0" in result.output


def test_issue_create_without_roadmap(temp_dir):
    """Test creating issue without initialized roadmap."""
    runner = CliRunner()
    result = runner.invoke(main, ["issue", "create", "test-issue"])
    assert result.exit_code == 0
    assert "Roadmap not initialized" in result.output


def test_issue_create_with_error(initialized_roadmap):
    """Test issue creation with error."""
    runner = CliRunner()
    with patch("roadmap.core.RoadmapCore.create_issue") as mock_create:
        mock_create.side_effect = Exception("Test error")
        result = runner.invoke(main, ["issue", "create", "test-issue"])
        assert result.exit_code == 0
        assert "Failed to create issue" in result.output


def test_issue_list_command_empty(initialized_roadmap):
    """Test listing issues when none exist."""
    runner = CliRunner()
    result = runner.invoke(main, ["issue", "list"])
    assert result.exit_code == 0
    assert "No all issues found" in result.output


def test_issue_list_command_with_issues(initialized_roadmap):
    """Test listing issues when they exist."""
    runner = CliRunner()

    # Create some issues first
    runner.invoke(main, ["issue", "create", "issue-1", "--priority", "high"])
    runner.invoke(main, ["issue", "create", "issue-2", "--priority", "low"])

    result = runner.invoke(main, ["issue", "list"])
    assert result.exit_code == 0
    assert "issue-1" in result.output
    assert "issue-2" in result.output


def test_issue_list_with_filters(initialized_roadmap):
    """Test listing issues with filters."""
    runner = CliRunner()

    # Create issues with different attributes
    runner.invoke(main, ["issue", "create", "high-issue", "--priority", "high"])
    runner.invoke(main, ["issue", "create", "low-issue", "--priority", "low"])

    # Test priority filter
    result = runner.invoke(main, ["issue", "list", "--priority", "high"])
    assert result.exit_code == 0
    assert "high-issue" in result.output
    assert "low-issue" not in result.output


def test_issue_list_without_roadmap(temp_dir):
    """Test listing issues without initialized roadmap."""
    runner = CliRunner()
    result = runner.invoke(main, ["issue", "list"])
    assert result.exit_code == 0
    assert "Roadmap not initialized" in result.output


def test_issue_list_with_error(initialized_roadmap):
    """Test issue listing with error."""
    runner = CliRunner()
    with patch("roadmap.core.RoadmapCore.list_issues") as mock_list:
        mock_list.side_effect = Exception("Test error")
        result = runner.invoke(main, ["issue", "list"])
        assert result.exit_code == 0
        assert "Failed to list issues" in result.output


def test_issue_update_command(initialized_roadmap):
    """Test updating an issue."""
    runner = CliRunner()

    # Create issue first
    result = runner.invoke(main, ["issue", "create", "test-issue"])
    issue_id = None
    for line in result.output.split("\n"):
        if "ID:" in line:
            issue_id = line.split(":")[1].strip()
            break

    assert issue_id is not None

    # Update the issue
    result = runner.invoke(
        main,
        ["issue", "update", issue_id, "--status", "in-progress", "--priority", "high"],
    )
    assert result.exit_code == 0
    assert "Updated issue" in result.output


def test_issue_update_not_found(initialized_roadmap):
    """Test updating non-existent issue."""
    runner = CliRunner()
    result = runner.invoke(main, ["issue", "update", "nonexistent", "--status", "done"])
    assert result.exit_code == 0
    assert "Issue not found" in result.output


def test_issue_update_without_roadmap(temp_dir):
    """Test updating issue without initialized roadmap."""
    runner = CliRunner()
    result = runner.invoke(main, ["issue", "update", "test-id", "--status", "done"])
    assert result.exit_code == 0
    assert "Roadmap not initialized" in result.output


def test_issue_delete_command(initialized_roadmap):
    """Test deleting an issue."""
    runner = CliRunner()

    # Create issue first
    result = runner.invoke(main, ["issue", "create", "test-issue"])
    issue_id = None
    for line in result.output.split("\n"):
        if "ID:" in line:
            issue_id = line.split(":")[1].strip()
            break

    assert issue_id is not None

    # Delete the issue (provide 'y' as input to confirmation prompt)
    result = runner.invoke(main, ["issue", "delete", issue_id], input="y\n")
    assert result.exit_code == 0
    assert "Permanently deleted issue" in result.output


def test_issue_delete_not_found(initialized_roadmap):
    """Test deleting non-existent issue."""
    runner = CliRunner()
    result = runner.invoke(main, ["issue", "delete", "nonexistent"], input="y\n")
    assert result.exit_code == 0
    assert "Issue not found" in result.output


def test_issue_delete_without_roadmap(temp_dir):
    """Test deleting issue without initialized roadmap."""
    runner = CliRunner()
    result = runner.invoke(main, ["issue", "delete", "test-id"], input="y\n")
    assert result.exit_code == 0
    assert "Roadmap not initialized" in result.output


# Milestone Commands Tests


def test_milestone_help(cli_runner):
    """Test milestone command help."""
    result = cli_runner.invoke(main, ["milestone", "--help"])
    assert result.exit_code == 0
    assert "Manage milestones" in result.output


def test_milestone_create_command(initialized_roadmap):
    """Test creating a milestone."""
    runner = CliRunner()
    result = runner.invoke(main, ["milestone", "create", "test-milestone"])
    assert result.exit_code == 0
    assert "Created milestone: test-milestone" in result.output


def test_milestone_create_with_description(initialized_roadmap):
    """Test creating milestone with description."""
    runner = CliRunner()
    result = runner.invoke(
        main, ["milestone", "create", "v1.0", "--description", "First release"]
    )
    assert result.exit_code == 0
    assert "Created milestone: v1.0" in result.output


def test_milestone_create_without_roadmap(temp_dir):
    """Test creating milestone without initialized roadmap."""
    runner = CliRunner()
    result = runner.invoke(main, ["milestone", "create", "test-milestone"])
    assert result.exit_code == 0
    assert "Roadmap not initialized" in result.output


def test_milestone_create_with_error(initialized_roadmap):
    """Test milestone creation with error."""
    runner = CliRunner()
    with patch("roadmap.core.RoadmapCore.create_milestone") as mock_create:
        mock_create.side_effect = Exception("Test error")
        result = runner.invoke(main, ["milestone", "create", "test-milestone"])
        assert result.exit_code == 0
        assert "Failed to create milestone" in result.output


def test_milestone_list_command_empty(initialized_roadmap):
    """Test listing milestones when none exist."""
    runner = CliRunner()
    result = runner.invoke(main, ["milestone", "list"])
    assert result.exit_code == 0
    assert "No milestones found" in result.output


def test_milestone_list_command_with_milestones(initialized_roadmap):
    """Test listing milestones when they exist."""
    runner = CliRunner()

    # Create some milestones first
    runner.invoke(main, ["milestone", "create", "v1.0"])
    runner.invoke(main, ["milestone", "create", "v2.0"])

    result = runner.invoke(main, ["milestone", "list"])
    assert result.exit_code == 0
    assert "v1.0" in result.output
    assert "v2.0" in result.output


def test_milestone_list_without_roadmap(temp_dir):
    """Test listing milestones without initialized roadmap."""
    runner = CliRunner()
    result = runner.invoke(main, ["milestone", "list"])
    assert result.exit_code == 0
    assert "Roadmap not initialized" in result.output


def test_milestone_list_with_error(initialized_roadmap):
    """Test milestone listing with error."""
    runner = CliRunner()
    with patch("roadmap.core.RoadmapCore.list_milestones") as mock_list:
        mock_list.side_effect = Exception("Test error")
        result = runner.invoke(main, ["milestone", "list"])
        assert result.exit_code == 0
        assert "Failed to list milestones" in result.output


def test_milestone_assign_command(initialized_roadmap):
    """Test assigning issue to milestone."""
    runner = CliRunner()

    # Create milestone and issue
    runner.invoke(main, ["milestone", "create", "v1.0"])
    result = runner.invoke(main, ["issue", "create", "test-issue"])

    # Extract issue ID
    issue_id = None
    for line in result.output.split("\n"):
        if "ID:" in line:
            issue_id = line.split(":")[1].strip()
            break

    assert issue_id is not None

    # Assign to milestone
    result = runner.invoke(main, ["milestone", "assign", issue_id, "v1.0"])
    assert result.exit_code == 0
    assert "Assigned issue" in result.output


def test_milestone_assign_issue_not_found(initialized_roadmap):
    """Test assigning non-existent issue to milestone."""
    runner = CliRunner()
    runner.invoke(main, ["milestone", "create", "v1.0"])

    result = runner.invoke(main, ["milestone", "assign", "nonexistent", "v1.0"])
    assert result.exit_code == 0
    assert "Failed to assign" in result.output


def test_milestone_assign_without_roadmap(temp_dir):
    """Test assigning issue to milestone without initialized roadmap."""
    runner = CliRunner()
    result = runner.invoke(main, ["milestone", "assign", "issue-id", "milestone"])
    assert result.exit_code == 0
    assert "Roadmap not initialized" in result.output


# Sync Commands Tests


def test_sync_help(cli_runner):
    """Test sync command help."""
    result = cli_runner.invoke(main, ["sync", "--help"])
    assert result.exit_code == 0
    assert "Synchronize with GitHub repository" in result.output


def test_sync_setup_command(initialized_roadmap):
    """Test sync setup command."""
    runner = CliRunner()
    with patch("roadmap.cli.SyncManager") as mock_sync_class:
        # Mock the SyncManager class to return a configured instance
        mock_instance = Mock()
        mock_instance.test_connection.return_value = (True, "Connection successful")
        mock_instance.setup_repository.return_value = (
            True,
            "Repository setup complete",
        )
        mock_sync_class.return_value = mock_instance

        result = runner.invoke(main, ["sync", "setup"])
        assert result.exit_code == 0
        assert "Connection successful" in result.output
        assert "Repository setup complete" in result.output


def test_sync_setup_without_roadmap(temp_dir):
    """Test sync setup without initialized roadmap."""
    runner = CliRunner()
    result = runner.invoke(main, ["sync", "setup"])
    assert result.exit_code == 0
    assert "Roadmap not initialized" in result.output


def test_sync_setup_not_configured(initialized_roadmap):
    """Test sync setup when GitHub not configured."""
    runner = CliRunner()
    # Default behavior - no mocking, so GitHub will not be configured
    result = runner.invoke(main, ["sync", "setup"])
    assert result.exit_code == 0
    assert "GitHub client not configured" in result.output


def test_sync_test_command(initialized_roadmap):
    """Test sync test command."""
    runner = CliRunner()
    with patch("roadmap.cli.SyncManager") as mock_sync_class:
        mock_instance = Mock()
        mock_instance.test_connection.return_value = (
            True,
            "GitHub connection successful",
        )
        mock_sync_class.return_value = mock_instance

        result = runner.invoke(main, ["sync", "test"])
        assert result.exit_code == 0
        assert "GitHub connection successful" in result.output


def test_sync_test_failure(initialized_roadmap):
    """Test sync test with connection failure."""
    runner = CliRunner()
    with patch("roadmap.cli.SyncManager") as mock_sync_class:
        mock_instance = Mock()
        mock_instance.test_connection.return_value = (False, "GitHub connection failed")
        mock_sync_class.return_value = mock_instance

        result = runner.invoke(main, ["sync", "test"])
        assert result.exit_code == 0
        assert "GitHub connection failed" in result.output


def test_sync_test_without_roadmap(temp_dir):
    """Test sync test without initialized roadmap."""
    runner = CliRunner()
    result = runner.invoke(main, ["sync", "test"])
    assert result.exit_code == 0
    assert "Roadmap not initialized" in result.output


def test_sync_test_not_configured(initialized_roadmap):
    """Test sync test when GitHub not configured."""
    runner = CliRunner()
    # Default behavior - no mocking, so GitHub will not be configured
    result = runner.invoke(main, ["sync", "test"])
    assert result.exit_code == 0
    assert "GitHub client not configured" in result.output


def test_sync_push_command(initialized_roadmap):
    """Test sync push command."""
    runner = CliRunner()
    with patch("roadmap.cli.SyncManager") as mock_sync_class:
        mock_instance = Mock()
        mock_instance.is_configured.return_value = True
        mock_instance.sync_all_issues.return_value = {"pushed": 2, "failed": 0}
        mock_instance.sync_all_milestones.return_value = {"pushed": 1, "failed": 0}
        mock_sync_class.return_value = mock_instance

        result = runner.invoke(main, ["sync", "push"])
        assert result.exit_code == 0
        assert "Pushing to GitHub" in result.output or "pushed" in result.output


def test_sync_push_issues_only(initialized_roadmap):
    """Test sync push issues only."""
    runner = CliRunner()
    with patch("roadmap.cli.SyncManager") as mock_sync_class:
        mock_instance = Mock()
        mock_instance.is_configured.return_value = True
        mock_instance.sync_all_issues.return_value = {"pushed": 2, "failed": 0}
        mock_sync_class.return_value = mock_instance

        result = runner.invoke(main, ["sync", "push", "--issues"])
        assert result.exit_code == 0
        assert "Pushing to GitHub" in result.output or "pushed" in result.output


def test_sync_push_without_roadmap(temp_dir):
    """Test sync push without initialized roadmap."""
    runner = CliRunner()
    result = runner.invoke(main, ["sync", "push"])
    assert result.exit_code == 0
    assert "Roadmap not initialized" in result.output


def test_sync_push_not_configured(initialized_roadmap):
    """Test sync push when GitHub not configured."""
    runner = CliRunner()
    # Default behavior - no mocking, so GitHub will not be configured
    result = runner.invoke(main, ["sync", "push"])
    assert result.exit_code == 0
    assert "GitHub integration not configured" in result.output


def test_sync_pull_command(initialized_roadmap):
    """Test sync pull command."""
    runner = CliRunner()
    with patch("roadmap.cli.SyncManager") as mock_sync_class:
        mock_instance = Mock()
        mock_instance.is_configured.return_value = True
        mock_instance.sync_all_issues.return_value = {"pulled": 3, "failed": 0}
        mock_instance.sync_all_milestones.return_value = {"pulled": 2, "failed": 0}
        mock_sync_class.return_value = mock_instance

        result = runner.invoke(main, ["sync", "pull"])
        assert result.exit_code == 0
        assert "Pulling from GitHub" in result.output or "pulled" in result.output


def test_sync_pull_milestones_only(initialized_roadmap):
    """Test sync pull milestones only."""
    runner = CliRunner()
    with patch("roadmap.cli.SyncManager") as mock_sync_class:
        mock_instance = Mock()
        mock_instance.is_configured.return_value = True
        mock_instance.sync_all_milestones.return_value = {"pulled": 2, "failed": 0}
        mock_sync_class.return_value = mock_instance

        result = runner.invoke(main, ["sync", "pull", "--milestones"])
        assert result.exit_code == 0
        assert "Pulling from GitHub" in result.output or "pulled" in result.output


def test_sync_pull_without_roadmap(temp_dir):
    """Test sync pull without initialized roadmap."""
    runner = CliRunner()
    result = runner.invoke(main, ["sync", "pull"])
    assert result.exit_code == 0
    assert "Roadmap not initialized" in result.output


def test_sync_pull_not_configured(initialized_roadmap):
    """Test sync pull when GitHub not configured."""
    runner = CliRunner()
    # Default behavior - no mocking, so GitHub will not be configured
    result = runner.invoke(main, ["sync", "pull"])
    assert result.exit_code == 0
    assert "GitHub integration not configured" in result.output


def test_issue_list_assignee_time_aggregation(initialized_roadmap):
    """Test that issue list shows time aggregation when filtering by assignee."""
    runner = CliRunner()

    # Create issues with different assignees and time estimates
    runner.invoke(
        main,
        [
            "issue",
            "create",
            "Backend task 1",
            "--assignee",
            "backend-team",
            "--estimate",
            "8.0",
        ],
    )
    runner.invoke(
        main,
        [
            "issue",
            "create",
            "Backend task 2",
            "--assignee",
            "backend-team",
            "--estimate",
            "4.0",
        ],
    )
    runner.invoke(
        main,
        [
            "issue",
            "create",
            "Frontend task",
            "--assignee",
            "frontend-team",
            "--estimate",
            "6.0",
        ],
    )

    # Test backend team aggregation
    result = runner.invoke(main, ["issue", "list", "--assignee", "backend-team"])
    assert result.exit_code == 0
    assert "2 assigned to backend-team issues" in result.output
    assert "Total estimated time for backend-team: 12.0h" in result.output
    assert "Workload breakdown:" in result.output
    assert "todo: 2 issues (12.0h)" in result.output

    # Test frontend team aggregation
    result = runner.invoke(main, ["issue", "list", "--assignee", "frontend-team"])
    assert result.exit_code == 0
    assert (
        "1 assigned to frontend-team issue" in result.output
    )  # singular when count is 1
    assert "Total estimated time for frontend-team: 6.0h" in result.output
    assert "todo: 1 issues (6.0h)" in result.output


def test_issue_list_assignee_mixed_statuses_time_aggregation(initialized_roadmap):
    """Test assignee time aggregation with mixed issue statuses."""
    runner = CliRunner()

    # Create issues and update some statuses
    runner.invoke(
        main,
        ["issue", "create", "Task 1", "--assignee", "dev-team", "--estimate", "8.0"],
    )
    runner.invoke(
        main,
        ["issue", "create", "Task 2", "--assignee", "dev-team", "--estimate", "4.0"],
    )
    runner.invoke(
        main,
        ["issue", "create", "Task 3", "--assignee", "dev-team", "--estimate", "2.0"],
    )

    # Get the created issue IDs and update their statuses
    list_result = runner.invoke(main, ["issue", "list", "--assignee", "dev-team"])
    lines = list_result.output.split("\n")

    # Extract issue IDs from table (they appear in the first column)
    issue_ids = []
    for line in lines:
        if "│" in line and len(line.split("│")) > 1:
            first_col = line.split("│")[1].strip()
            if len(first_col) == 8:  # Issue ID length
                issue_ids.append(first_col)

    if len(issue_ids) >= 3:
        # Update statuses to create mixed breakdown
        runner.invoke(
            main, ["issue", "update", issue_ids[0], "--status", "in-progress"]
        )
        runner.invoke(main, ["issue", "update", issue_ids[1], "--status", "done"])
        # Leave third as todo

        # Test the aggregation with mixed statuses
        result = runner.invoke(main, ["issue", "list", "--assignee", "dev-team"])
        assert result.exit_code == 0
        assert "Total estimated time for dev-team: 14.0h" in result.output
        assert "Remaining work (excluding done): 10.0h" in result.output
        assert "in-progress: 1 issues (8.0h)" in result.output
        assert "done: 1 issues (4.0h)" in result.output
        assert "todo: 1 issues (2.0h)" in result.output


# Additional CLI command tests for improved coverage
def test_issue_close_command(initialized_roadmap):
    """Test closing an issue."""
    runner = CliRunner()

    # Create an issue first
    result = runner.invoke(main, ["issue", "create", "test-issue"])
    assert result.exit_code == 0

    # Extract issue ID
    output_lines = result.output.split("\n")
    id_line = [line for line in output_lines if "ID:" in line][0]
    issue_id = id_line.split("ID:")[1].strip()

    # Close the issue
    result = runner.invoke(main, ["issue", "close", issue_id])
    assert result.exit_code == 0
    assert "✅ Closed issue: test-issue" in result.output
    assert "Status: ✅ Done" in result.output


def test_issue_close_command_with_reason(initialized_roadmap):
    """Test closing an issue with a reason."""
    runner = CliRunner()

    # Create an issue first
    result = runner.invoke(main, ["issue", "create", "test-issue"])
    assert result.exit_code == 0

    # Extract issue ID
    output_lines = result.output.split("\n")
    id_line = [line for line in output_lines if "ID:" in line][0]
    issue_id = id_line.split("ID:")[1].strip()

    # Close the issue with reason
    result = runner.invoke(
        main, ["issue", "close", issue_id, "--reason", "Duplicate of #123"]
    )
    assert result.exit_code == 0
    assert "✅ Closed issue: test-issue" in result.output
    assert "Reason: Duplicate of #123" in result.output


def test_issue_close_command_nonexistent(initialized_roadmap):
    """Test closing a non-existent issue."""
    runner = CliRunner()

    result = runner.invoke(main, ["issue", "close", "nonexistent"])
    assert result.exit_code == 0
    assert "❌ Issue not found: nonexistent" in result.output


def test_issue_close_command_without_roadmap(temp_dir):
    """Test closing an issue without initialized roadmap."""
    runner = CliRunner()

    result = runner.invoke(main, ["issue", "close", "some-id"])
    assert result.exit_code == 0
    assert "❌ Roadmap not initialized" in result.output


def test_issue_block_command(initialized_roadmap):
    """Test blocking an issue."""
    runner = CliRunner()

    # Create an issue first
    result = runner.invoke(main, ["issue", "create", "test-issue"])
    assert result.exit_code == 0

    # Extract issue ID
    output_lines = result.output.split("\n")
    id_line = [line for line in output_lines if "ID:" in line][0]
    issue_id = id_line.split("ID:")[1].strip()

    # Block the issue
    result = runner.invoke(main, ["issue", "block", issue_id])
    assert result.exit_code == 0
    assert "🚫 Blocked issue: test-issue" in result.output
    assert "Status: 🚫 Blocked" in result.output


def test_issue_block_command_with_reason(initialized_roadmap):
    """Test blocking an issue with a reason."""
    runner = CliRunner()

    # Create an issue first
    result = runner.invoke(main, ["issue", "create", "test-issue"])
    assert result.exit_code == 0

    # Extract issue ID
    output_lines = result.output.split("\n")
    id_line = [line for line in output_lines if "ID:" in line][0]
    issue_id = id_line.split("ID:")[1].strip()

    # Block the issue with reason
    result = runner.invoke(
        main, ["issue", "block", issue_id, "--reason", "Waiting for API access"]
    )
    assert result.exit_code == 0
    assert "🚫 Blocked issue: test-issue" in result.output
    assert "Reason: Waiting for API access" in result.output


def test_issue_block_command_nonexistent(initialized_roadmap):
    """Test blocking a non-existent issue."""
    runner = CliRunner()

    result = runner.invoke(main, ["issue", "block", "nonexistent"])
    assert result.exit_code == 0
    assert "❌ Issue not found: nonexistent" in result.output


def test_issue_block_command_without_roadmap(temp_dir):
    """Test blocking an issue without initialized roadmap."""
    runner = CliRunner()

    result = runner.invoke(main, ["issue", "block", "some-id"])
    assert result.exit_code == 0
    assert "❌ Roadmap not initialized" in result.output


class TestSyncBidirectionalCommand:
    """Test the new sync bidirectional command."""

    @pytest.fixture
    def mock_sync_manager(self):
        """Mock SyncManager for testing."""
        with patch("roadmap.cli.SyncManager") as mock_sm:
            manager = Mock()
            mock_sm.return_value = manager
            manager.is_configured.return_value = True
            manager.bidirectional_sync.return_value = (5, 0, [], [])
            yield manager

    def test_sync_bidirectional_success(self, initialized_roadmap, mock_sync_manager):
        """Test successful bidirectional sync."""
        runner = CliRunner()

        with patch("roadmap.cli.RoadmapCore") as mock_core:
            mock_core.return_value.is_initialized.return_value = True
            mock_core.return_value.load_config.return_value = Mock()

            result = runner.invoke(main, ["sync", "bidirectional"])

            assert result.exit_code == 0
            assert "🔄 Starting bidirectional synchronization" in result.output
            assert "✅ Successfully synchronized 5 items" in result.output

    def test_sync_bidirectional_not_initialized(self, temp_dir):
        """Test bidirectional sync without initialized roadmap."""
        runner = CliRunner()

        result = runner.invoke(main, ["sync", "bidirectional"])
        assert result.exit_code == 0
        assert "❌ Roadmap not initialized" in result.output

    def test_sync_bidirectional_not_configured(
        self, initialized_roadmap, mock_sync_manager
    ):
        """Test bidirectional sync without GitHub configuration."""
        runner = CliRunner()
        mock_sync_manager.is_configured.return_value = False

        with patch("roadmap.cli.RoadmapCore") as mock_core:
            mock_core.return_value.is_initialized.return_value = True
            mock_core.return_value.load_config.return_value = Mock()

            result = runner.invoke(main, ["sync", "bidirectional"])

            assert result.exit_code == 0
            assert "❌ GitHub integration not configured" in result.output

    def test_sync_bidirectional_with_strategy(
        self, initialized_roadmap, mock_sync_manager
    ):
        """Test bidirectional sync with different strategies."""
        runner = CliRunner()

        with patch("roadmap.cli.RoadmapCore") as mock_core:
            mock_core.return_value.is_initialized.return_value = True
            mock_core.return_value.load_config.return_value = Mock()

            # Test local_wins strategy
            result = runner.invoke(
                main, ["sync", "bidirectional", "--strategy", "local_wins"]
            )
            assert result.exit_code == 0
            assert "📋 Strategy: local_wins" in result.output

            # Test remote_wins strategy
            result = runner.invoke(
                main, ["sync", "bidirectional", "--strategy", "remote_wins"]
            )
            assert result.exit_code == 0
            assert "📋 Strategy: remote_wins" in result.output

    def test_sync_bidirectional_issues_only(
        self, initialized_roadmap, mock_sync_manager
    ):
        """Test bidirectional sync for issues only."""
        runner = CliRunner()

        with patch("roadmap.cli.RoadmapCore") as mock_core:
            mock_core.return_value.is_initialized.return_value = True
            mock_core.return_value.load_config.return_value = Mock()

            result = runner.invoke(main, ["sync", "bidirectional", "--issues"])

            assert result.exit_code == 0
            mock_sync_manager.bidirectional_sync.assert_called_with(
                sync_issues=True, sync_milestones=False
            )

    def test_sync_bidirectional_milestones_only(
        self, initialized_roadmap, mock_sync_manager
    ):
        """Test bidirectional sync for milestones only."""
        runner = CliRunner()

        with patch("roadmap.cli.RoadmapCore") as mock_core:
            mock_core.return_value.is_initialized.return_value = True
            mock_core.return_value.load_config.return_value = Mock()

            result = runner.invoke(main, ["sync", "bidirectional", "--milestones"])

            assert result.exit_code == 0
            mock_sync_manager.bidirectional_sync.assert_called_with(
                sync_issues=False, sync_milestones=True
            )

    def test_sync_bidirectional_with_conflicts(
        self, initialized_roadmap, mock_sync_manager
    ):
        """Test bidirectional sync with conflicts detected."""
        runner = CliRunner()

        from datetime import datetime

        from roadmap.models import Issue
        from roadmap.sync import SyncConflict

        # Mock conflicts
        conflict = SyncConflict(
            "issue",
            "1",
            Issue(id="1", title="Test"),
            {"number": 1},
            datetime.now(),
            datetime.now(),
        )
        mock_sync_manager.bidirectional_sync.return_value = (
            3,
            1,
            ["Error msg"],
            [conflict],
        )
        mock_sync_manager.sync_strategy.resolve_conflict.return_value = "use_local"

        with patch("roadmap.cli.RoadmapCore") as mock_core:
            mock_core.return_value.is_initialized.return_value = True
            mock_core.return_value.load_config.return_value = Mock()

            result = runner.invoke(main, ["sync", "bidirectional"])

            assert result.exit_code == 0
            assert "⚠️  1 conflicts detected and resolved" in result.output
            assert "❌ 1 errors occurred" in result.output

    def test_sync_bidirectional_dry_run(self, initialized_roadmap, mock_sync_manager):
        """Test bidirectional sync dry run mode."""
        runner = CliRunner()

        with patch("roadmap.cli.RoadmapCore") as mock_core:
            mock_core.return_value.is_initialized.return_value = True
            mock_core.return_value.load_config.return_value = Mock()

            result = runner.invoke(main, ["sync", "bidirectional", "--dry-run"])

            assert result.exit_code == 0
            assert "🔍 DRY RUN - No changes will be made" in result.output
            assert "⚠️  Dry run mode not yet implemented" in result.output

    def test_sync_bidirectional_exception_handling(
        self, initialized_roadmap, mock_sync_manager
    ):
        """Test bidirectional sync exception handling."""
        runner = CliRunner()
        mock_sync_manager.bidirectional_sync.side_effect = Exception("Test error")

        with patch("roadmap.cli.RoadmapCore") as mock_core:
            mock_core.return_value.is_initialized.return_value = True
            mock_core.return_value.load_config.return_value = Mock()

            result = runner.invoke(main, ["sync", "bidirectional"])

            assert result.exit_code == 0
            assert "❌ Failed to perform bidirectional sync" in result.output


class TestMilestoneUpdateCommand:
    """Test the milestone update command."""

    def test_milestone_update_success(self, initialized_roadmap):
        """Test successful milestone update."""
        runner = CliRunner()

        # Create a milestone first
        runner.invoke(main, ["milestone", "create", "Test Milestone"])

        with patch("roadmap.cli.RoadmapCore") as mock_core:
            mock_core.return_value.is_initialized.return_value = True
            mock_milestone = Mock()
            mock_milestone.name = "Test Milestone"
            mock_milestone.description = "Updated description"
            mock_milestone.due_date = None
            mock_milestone.status.value = "open"
            mock_core.return_value.get_milestone.return_value = mock_milestone
            mock_core.return_value.update_milestone.return_value = True

            result = runner.invoke(
                main,
                [
                    "milestone",
                    "update",
                    "Test Milestone",
                    "--description",
                    "Updated description",
                ],
            )

            assert result.exit_code == 0
            assert "✅ Updated milestone: Test Milestone" in result.output

    def test_milestone_update_not_found(self, initialized_roadmap):
        """Test milestone update when milestone not found."""
        runner = CliRunner()

        with patch("roadmap.cli.RoadmapCore") as mock_core_class:
            # Mock the find_existing_roadmap class method
            mock_core_instance = Mock()
            mock_core_class.find_existing_roadmap.return_value = mock_core_instance
            mock_core_instance.is_initialized.return_value = True
            mock_core_instance.get_milestone.return_value = None

            result = runner.invoke(main, ["milestone", "update", "NonExistent", "--description", "Test"])

            assert result.exit_code == 0
            assert "❌ Milestone not found: NonExistent" in result.output

    def test_milestone_update_no_options(self, initialized_roadmap):
        """Test milestone update with no update options provided."""
        runner = CliRunner()

        with patch("roadmap.cli.RoadmapCore") as mock_core:
            mock_core.return_value.is_initialized.return_value = True
            mock_milestone = Mock()
            mock_core.return_value.get_milestone.return_value = mock_milestone

            result = runner.invoke(main, ["milestone", "update", "Test Milestone"])

            assert result.exit_code == 0
            assert "❌ No updates specified" in result.output

    def test_milestone_update_invalid_date(self, initialized_roadmap):
        """Test milestone update with invalid date format."""
        runner = CliRunner()

        with patch("roadmap.cli.RoadmapCore") as mock_core:
            mock_core.return_value.is_initialized.return_value = True
            mock_milestone = Mock()
            mock_core.return_value.get_milestone.return_value = mock_milestone

            result = runner.invoke(
                main,
                ["milestone", "update", "Test Milestone", "--due-date", "invalid-date"],
            )

            assert result.exit_code == 0
            assert "❌ Invalid due date format" in result.output

    def test_milestone_update_clear_due_date(self, initialized_roadmap):
        """Test milestone update clearing due date."""
        runner = CliRunner()

        with patch("roadmap.cli.RoadmapCore") as mock_core:
            mock_core.return_value.is_initialized.return_value = True
            mock_milestone = Mock()
            mock_milestone.name = "Test Milestone"
            mock_milestone.due_date = None
            mock_core.return_value.get_milestone.return_value = mock_milestone
            mock_core.return_value.update_milestone.return_value = True

            result = runner.invoke(
                main, ["milestone", "update", "Test Milestone", "--due-date", "clear"]
            )

            assert result.exit_code == 0
            assert "✅ Updated milestone: Test Milestone" in result.output


class TestErrorHandlingCLI:
    """Test error handling across CLI commands."""

    def test_issue_create_without_init(self, temp_dir):
        """Test creating issue without roadmap initialization."""
        runner = CliRunner()

        result = runner.invoke(main, ["issue", "create", "Test Issue"])
        assert result.exit_code == 0
        assert "❌ Roadmap not initialized" in result.output

    def test_milestone_create_without_init(self, temp_dir):
        """Test creating milestone without roadmap initialization."""
        runner = CliRunner()

        result = runner.invoke(main, ["milestone", "create", "Test Milestone"])
        assert result.exit_code == 0
        assert "❌ Roadmap not initialized" in result.output

    def test_status_without_init(self, temp_dir):
        """Test status command without roadmap initialization."""
        runner = CliRunner()

        result = runner.invoke(main, ["status"])
        assert result.exit_code == 0
        assert "❌ Roadmap not initialized" in result.output

    def test_sync_setup_without_init(self, temp_dir):
        """Test sync setup without roadmap initialization."""
        runner = CliRunner()

        result = runner.invoke(main, ["sync", "setup"])
        assert result.exit_code == 0
        assert "❌ Roadmap not initialized" in result.output

    def test_sync_push_without_init(self, temp_dir):
        """Test sync push without roadmap initialization."""
        runner = CliRunner()

        result = runner.invoke(main, ["sync", "push"])
        assert result.exit_code == 0
        assert "❌ Roadmap not initialized" in result.output

    def test_sync_pull_without_init(self, temp_dir):
        """Test sync pull without roadmap initialization."""
        runner = CliRunner()

        result = runner.invoke(main, ["sync", "pull"])
        assert result.exit_code == 0
        assert "❌ Roadmap not initialized" in result.output

    def test_sync_test_without_init(self, temp_dir):
        """Test sync test without roadmap initialization."""
        runner = CliRunner()

        result = runner.invoke(main, ["sync", "test"])
        assert result.exit_code == 0
        assert "❌ Roadmap not initialized" in result.output

    def test_sync_status_without_init(self, temp_dir):
        """Test sync status without roadmap initialization."""
        runner = CliRunner()

        result = runner.invoke(main, ["sync", "status"])
        assert result.exit_code == 0
        assert "❌ Roadmap not initialized" in result.output

    def test_issue_commands_exception_handling(self, initialized_roadmap):
        """Test exception handling in issue commands."""
        runner = CliRunner()

        with patch("roadmap.cli.RoadmapCore") as mock_core_class:
            # Mock the find_existing_roadmap class method
            mock_core_instance = Mock()
            mock_core_class.find_existing_roadmap.return_value = mock_core_instance
            mock_core_instance.is_initialized.return_value = True
            mock_core_instance.create_issue.side_effect = Exception("Database error")

            result = runner.invoke(main, ["issue", "create", "Test Issue"])

            assert result.exit_code == 0
            assert "❌ Failed to create issue" in result.output

    def test_milestone_commands_exception_handling(self, initialized_roadmap):
        """Test exception handling in milestone commands."""
        runner = CliRunner()

        with patch("roadmap.cli.RoadmapCore") as mock_core_class:
            # Mock the find_existing_roadmap class method
            mock_core_instance = Mock()
            mock_core_class.find_existing_roadmap.return_value = mock_core_instance
            mock_core_instance.is_initialized.return_value = True
            mock_core_instance.create_milestone.side_effect = Exception("Database error")

            result = runner.invoke(main, ["milestone", "create", "Test Milestone"])

            assert result.exit_code == 0
            assert "❌ Failed to create milestone" in result.output


class TestSyncCommands:
    """Test additional sync command coverage."""

    def test_sync_setup_success(self, initialized_roadmap):
        """Test successful sync setup."""
        runner = CliRunner()

        with patch("roadmap.cli.RoadmapCore") as mock_core:
            mock_core.return_value.is_initialized.return_value = True
            # Create a proper config mock with github attribute
            mock_config = Mock()
            mock_config.github = {}  # Add the github dict
            mock_config.save_to_file = Mock()
            mock_core.return_value.load_config.return_value = mock_config
            mock_core.return_value.save_config.return_value = None

            with patch("roadmap.cli.SyncManager") as mock_sync:
                manager = Mock()
                mock_sync.return_value = manager
                manager.test_connection.return_value = (True, "Success")
                manager.setup_repository.return_value = (True, "Setup complete")
                manager.store_token_secure.return_value = (
                    True,
                    "Token stored securely",
                )

                result = runner.invoke(
                    main,
                    ["sync", "setup", "--token", "test_token", "--repo", "owner/repo"],
                )

                assert result.exit_code == 0
                assert "✅ Token stored securely" in result.output
                assert "✅ Setup complete" in result.output

    def test_sync_test_success(self, initialized_roadmap):
        """Test successful sync test."""
        runner = CliRunner()

        with patch("roadmap.cli.RoadmapCore") as mock_core:
            mock_core.return_value.is_initialized.return_value = True
            mock_core.return_value.load_config.return_value = Mock()

            with patch("roadmap.cli.SyncManager") as mock_sync:
                manager = Mock()
                mock_sync.return_value = manager
                manager.is_configured.return_value = True
                manager.test_connection.return_value = (True, "Connection successful")

                result = runner.invoke(main, ["sync", "test"])

                assert result.exit_code == 0
                assert "✅ Connection successful" in result.output

    def test_sync_test_failure(self, initialized_roadmap):
        """Test sync test failure."""
        runner = CliRunner()

        with patch("roadmap.cli.RoadmapCore") as mock_core:
            mock_core.return_value.is_initialized.return_value = True
            mock_core.return_value.load_config.return_value = Mock()

            with patch("roadmap.cli.SyncManager") as mock_sync:
                manager = Mock()
                mock_sync.return_value = manager
                manager.is_configured.return_value = True
                manager.test_connection.return_value = (False, "Connection failed")

                result = runner.invoke(main, ["sync", "test"])

                assert result.exit_code == 0
                assert "❌ Connection failed" in result.output

    def test_sync_status_configured(self, initialized_roadmap):
        """Test sync status when configured."""
        runner = CliRunner()

        with patch("roadmap.cli.RoadmapCore") as mock_core:
            mock_core.return_value.is_initialized.return_value = True
            mock_core.return_value.load_config.return_value = Mock()

            with patch("roadmap.cli.SyncManager") as mock_sync:
                manager = Mock()
                mock_sync.return_value = manager
                manager.is_configured.return_value = True
                # Fix the unpacking error by returning proper tuples
                manager.get_sync_status.return_value = (
                    True,
                    "Configured",
                    {"status": "ok"},
                )

                result = runner.invoke(main, ["sync", "status"])

                assert result.exit_code == 0
                assert "GitHub Integration Status" in result.output


class TestTeamCommands:
    """Test team collaboration command coverage."""

    def test_team_list_members_success(self, initialized_roadmap):
        """Test listing team members successfully."""
        runner = CliRunner()

        with patch("roadmap.cli.RoadmapCore") as mock_core_class:
            # Mock the find_existing_roadmap class method
            mock_core_instance = Mock()
            mock_core_class.find_existing_roadmap.return_value = mock_core_instance
            mock_core_instance.is_initialized.return_value = True
            mock_core_instance.get_team_members.return_value = [
                "alice",
                "bob",
                "charlie",
            ]

            result = runner.invoke(main, ["team", "members"])

            assert result.exit_code == 0
            assert "alice" in result.output
            assert "bob" in result.output
            assert "charlie" in result.output


class TestRoadmapCommands:
    """Test roadmap-related CLI commands with proper isolation."""

    @pytest.fixture
    def isolated_roadmap_dir(self):
        """Create an isolated temporary roadmap directory for testing."""
        with tempfile.TemporaryDirectory() as temp_dir:
            original_cwd = os.getcwd()
            try:
                # Change to temp directory
                os.chdir(temp_dir)
                
                # Initialize roadmap in temp directory
                from roadmap.core import RoadmapCore
                core = RoadmapCore()
                core.initialize()
                
                yield temp_dir
            finally:
                # Always restore original directory
                os.chdir(original_cwd)

    def test_roadmap_help(self, cli_runner, isolated_roadmap_dir):
        """Test roadmap help command."""
        result = cli_runner.invoke(main, ["roadmap", "--help"])
        assert result.exit_code == 0
        assert "Manage roadmaps" in result.output
        assert "create" in result.output
        assert "overview" in result.output

    def test_roadmap_create_command(self, cli_runner, isolated_roadmap_dir):
        """Test roadmap create command."""
        result = cli_runner.invoke(main, [
            "roadmap", "create", "test-roadmap",
            "--description", "A test roadmap",
            "--owner", "testuser",
            "--priority", "high"
        ])
        assert result.exit_code == 0
        assert "Created roadmap" in result.output
        
        # Verify roadmap file was created in temp directory
        projects_dir = os.path.join(isolated_roadmap_dir, ".roadmap", "projects")
        assert os.path.exists(projects_dir)
        roadmap_files = [f for f in os.listdir(projects_dir) if f.endswith('.md')]
        assert len(roadmap_files) == 1
        
        # Verify roadmap file content
        roadmap_file = os.path.join(projects_dir, roadmap_files[0])
        with open(roadmap_file, 'r') as f:
            content = f.read()
            assert "test-roadmap" in content
            assert "A test roadmap" in content
            assert "testuser" in content
            assert "priority: \"high\"" in content

    def test_roadmap_create_with_all_options(self, cli_runner, isolated_roadmap_dir):
        """Test roadmap create command with all options."""
        result = cli_runner.invoke(main, [
            "roadmap", "create", "full-roadmap",
            "--description", "A comprehensive test roadmap",
            "--owner", "developer",
            "--priority", "critical",
            "--start-date", "2025-01-01",
            "--target-end-date", "2025-03-01",
            "--estimated-hours", "40.5",
            "--milestones", "v1.0",
            "--milestones", "v2.0"
        ])
        assert result.exit_code == 0
        assert "Created roadmap" in result.output

    def test_roadmap_create_without_roadmap(self, cli_runner):
        """Test roadmap create command without initialized roadmap."""
        with tempfile.TemporaryDirectory() as temp_dir:
            original_cwd = os.getcwd()
            try:
                os.chdir(temp_dir)
                result = cli_runner.invoke(main, [
                    "roadmap", "create", "test-roadmap"
                ])
                # The command might succeed if it creates a roadmap automatically
                # or fail if it requires manual initialization
                if result.exit_code != 0:
                    assert "not initialized" in result.output.lower() or "error" in result.output.lower()
            finally:
                os.chdir(original_cwd)

    def test_roadmap_overview_command(self, cli_runner, isolated_roadmap_dir):
        """Test roadmap overview command."""
        # First create a roadmap
        create_result = cli_runner.invoke(main, [
            "roadmap", "create", "overview-test",
            "--description", "Roadmap for overview testing"
        ])
        assert create_result.exit_code == 0
        
        # Extract roadmap ID from the create output
        import re
        id_match = re.search(r'ID: ([a-f0-9]+)', create_result.output)
        assert id_match is not None
        roadmap_id = id_match.group(1)
        
        # Then test overview with specific roadmap ID
        result = cli_runner.invoke(main, ["roadmap", "overview", roadmap_id])
        # Should succeed and show roadmap details
        assert result.exit_code == 0
        assert "Roadmap:" in result.output

    def test_roadmap_overview_without_roadmap(self, cli_runner):
        """Test roadmap overview command without initialized roadmap."""
        with tempfile.TemporaryDirectory() as temp_dir:
            original_cwd = os.getcwd()
            try:
                os.chdir(temp_dir)
                result = cli_runner.invoke(main, ["roadmap", "overview"])
                # Command should either fail gracefully or handle missing roadmap
                if result.exit_code != 0 and result.output:
                    assert "not initialized" in result.output.lower() or "error" in result.output.lower()
            finally:
                os.chdir(original_cwd)

    def test_roadmap_create_invalid_priority(self, cli_runner, isolated_roadmap_dir):
        """Test roadmap create with invalid priority."""
        result = cli_runner.invoke(main, [
            "roadmap", "create", "invalid-priority-roadmap",
            "--priority", "invalid"
        ])
        assert result.exit_code != 0

    def test_roadmap_create_invalid_date_format(self, cli_runner, isolated_roadmap_dir):
        """Test roadmap create with invalid date format."""
        result = cli_runner.invoke(main, [
            "roadmap", "create", "invalid-date-roadmap",
            "--start-date", "invalid-date"
        ])
        # The command might succeed if it gracefully handles invalid dates
        # or fail with validation error - both are acceptable
        if result.exit_code != 0:
            assert "error" in result.output.lower() or "invalid" in result.output.lower()

    def test_roadmap_update_command(self, cli_runner, isolated_roadmap_dir):
        """Test roadmap update command."""
        # First create a roadmap
        create_result = cli_runner.invoke(main, [
            "roadmap", "create", "update-test",
            "--description", "Roadmap for update testing",
            "--priority", "medium"
        ])
        assert create_result.exit_code == 0
        
        # Extract roadmap ID from the create output
        import re
        id_match = re.search(r'ID: ([a-f0-9]+)', create_result.output)
        assert id_match is not None
        roadmap_id = id_match.group(1)
        
        # Then test update
        result = cli_runner.invoke(main, [
            "roadmap", "update", roadmap_id,
            "--priority", "high",
            "--status", "active",
            "--add-milestone", "Phase 1"
        ])
        assert result.exit_code == 0
        assert "Updated roadmap" in result.output
        assert "priority: high" in result.output
        assert "status: active" in result.output
        assert "added milestone: Phase 1" in result.output

    def test_roadmap_list_command(self, cli_runner, isolated_roadmap_dir):
        """Test roadmap list command."""
        # First create a few roadmaps
        cli_runner.invoke(main, [
            "roadmap", "create", "list-test-1",
            "--priority", "high"
        ])
        cli_runner.invoke(main, [
            "roadmap", "create", "list-test-2", 
            "--priority", "low"
        ])
        
        # Test list all
        result = cli_runner.invoke(main, ["roadmap", "list"])
        assert result.exit_code == 0
        assert "list-test-1" in result.output
        assert "list-test-2" in result.output
        
        # Test list with filter
        result = cli_runner.invoke(main, ["roadmap", "list", "--priority", "high"])
        assert result.exit_code == 0
        assert "list-test-1" in result.output
        assert "list-test-2" not in result.output

    def test_roadmap_delete_command(self, cli_runner, isolated_roadmap_dir):
        """Test roadmap delete command."""
        # First create a roadmap
        create_result = cli_runner.invoke(main, [
            "roadmap", "create", "delete-test",
            "--description", "Roadmap for delete testing"
        ])
        assert create_result.exit_code == 0
        
        # Extract roadmap ID from the create output
        import re
        id_match = re.search(r'ID: ([a-f0-9]+)', create_result.output)
        assert id_match is not None
        roadmap_id = id_match.group(1)
        
        # Then test delete with confirm flag
        result = cli_runner.invoke(main, [
            "roadmap", "delete", roadmap_id, "--confirm"
        ])
        assert result.exit_code == 0
        assert "Deleted roadmap" in result.output
        
        # Verify roadmap was actually deleted
        list_result = cli_runner.invoke(main, ["roadmap", "list"])
        assert "delete-test" not in list_result.output
